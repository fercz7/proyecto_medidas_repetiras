real Y[N];
}
parameters {
// beta0: intercepto
real beta0;
// beta1: pendiente general
real beta1;
// tauR: efectos de riegoWW
real tauR;
// tauH: efectos de hongosHMA+
real tauH;
// delta: efectos de interacion dia:riegoWW
real delta;
// beta0i: efectos aleatorios sobre interceptos
real beta0i[p];
// beta1i: efectos aleatorios sobre pendiente
real beta1i[p];
// sigma0: desviación estándar de interceptos
real<lower=0> sigma0;
// sigma1: desviación estándar de pendientes
real<lower=0> sigma1;
// sigma_error: desviación estándar del error
real<lower=0> sigma_error;
}
transformed parameters  {
// Media condicional
real mu[N];
for (i in 1:N) {
mu[i] = beta0 + beta1*dia[i] + tauR*riegoWW[i] + tauH*hongosH[i] + delta*dia[i]*riegoWW[i] +
beta0i[1]*p12[i]+
beta0i[2]*p13[i]+
beta0i[3]*p14[i]+
beta0i[4]*p15[i]+
beta0i[5]*p16[i]+
beta0i[6]*p18[i]+
beta0i[7]*p19[i]+
beta0i[8]*p21[i]+
beta0i[9]*p210[i]+
beta0i[10]*p23[i]+
beta0i[11]*p24[i]+
beta0i[12]*p25[i]+
beta0i[13]*p26[i]+
beta0i[14]*p27[i]+
beta0i[15]*p29[i]+
beta0i[16]*p310[i]+
beta0i[17]*p32[i]+
beta0i[18]*p33[i]+
beta0i[19]*p34[i]+
beta0i[20]*p35[i]+
beta0i[21]*p36[i]+
beta0i[22]*p37[i]+
beta0i[23]*p38[i]+
beta0i[24]*p41[i]+
beta0i[25]*p410[i]+
beta0i[26]*p42[i]+
beta0i[27]*p43[i]+
beta0i[28]*p44[i]+
beta0i[29]*p45[i]+
beta0i[30]*p46[i]+
beta0i[31]*p47[i]+
beta0i[32]*p48[i]+
beta0i[33]*p49[i]+
beta1i[1]*p12[i]*dia[i]+
beta1i[2]*p13[i]*dia[i]+
beta1i[3]*p14[i]*dia[i]+
beta1i[4]*p15[i]*dia[i]+
beta1i[5]*p16[i]*dia[i]+
beta1i[6]*p18[i]*dia[i]+
beta1i[7]*p19[i]*dia[i]+
beta1i[8]*p21[i]*dia[i]+
beta1i[9]*p210[i]*dia[i]+
beta1i[10]*p23[i]*dia[i]+
beta1i[11]*p24[i]*dia[i]+
beta1i[12]*p25[i]*dia[i]+
beta1i[13]*p26[i]*dia[i]+
beta1i[14]*p27[i]*dia[i]+
beta1i[15]*p29[i]*dia[i]+
beta1i[16]*p310[i]*dia[i]+
beta1i[17]*p32[i]*dia[i]+
beta1i[18]*p33[i]*dia[i]+
beta1i[19]*p34[i]*dia[i]+
beta1i[20]*p35[i]*dia[i]+
beta1i[21]*p36[i]*dia[i]+
beta1i[22]*p37[i]*dia[i]+
beta1i[23]*p38[i]*dia[i]+
beta1i[24]*p41[i]*dia[i]+
beta1i[25]*p410[i]*dia[i]+
beta1i[26]*p42[i]*dia[i]+
beta1i[27]*p43[i]*dia[i]+
beta1i[28]*p44[i]*dia[i]+
beta1i[29]*p45[i]*dia[i]+
beta1i[30]*p46[i]*dia[i]+
beta1i[31]*p47[i]*dia[i]+
beta1i[32]*p48[i]*dia[i]+
beta1i[33]*p49[i]*dia[i];
}
}
model {
beta0i ~ normal(0, sigma0);
beta1i ~ normal(0, sigma1);
Y ~ normal(mu, sigma_error);
}
"
stan.fit1 <- stan(
model_code = stan.mod1,
data       = dat,
chains     = 2,
iter       = 100,
warmup     = 50,
cores      = parallel::detectCores(),
)
traceplot(stan.fit1, pars = c("beta0","beta1","sigma0","sigma1", "sigma_error"), inc_warmup = TRUE)
traceplot(stan.fit1, pars = c("beta0","beta1","sigma0","sigma1", "sigma_error"), inc_warmup = FALSE)
stan.fit1 <- stan(
model_code = stan.mod1,
data       = dat,
chains     = 1,
iter       = 100,
warmup     = 50,
cores      = parallel::detectCores(),
)
87+93-94
87+93
View(base2)
library( dplyr)
library(rstan)
library(lme4)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
base = openxlsx::read.xlsx("base.xlsx")
vacios = names(which(table(base$altura,base$planta)[1,]>1))
`%notin%` <- Negate(`%in%`)
#1:40
base2 <- base %>% filter( planta %notin% vacios)
mod4g = lme4::lmer( diametro ~ dia+riego+hongos+dia*riego+ (1|planta) + (0+dia|planta) , REML = F, data = base2)
summary(mod4g)
#1:40
base2 <- base %>% filter( planta %notin% vacios)
View(base2)
base2$planta
is.factor(base2$planta)
base2$planta = as.factor(base2$planta)
levels(base2$planta)
mod4g = lme4::lmer( diametro ~ dia+riego+hongos+dia*riego+ (1|planta) + (0+dia|planta) , REML = F, data = base2)
summary(mod4g)
xa=t(as.matrix(attributes(mod4g)$pp$Zt))[,1:33]
dat.a=as.list(as.data.frame(xa))
names(dat.a)
dat.f=as.list(as.data.frame(model.matrix(mod4g)))
names(dat.f)
names(dat.f)=c("intercepto","dia","riegoWW","hongosH", "dia:riegoWW")
names(dat.f)
dat=c(dat.f, dat.a)
names(dat)
names(dat.f)=c("intercepto","dia","riegoWW","hongosH", "diariegoWW")
names(dat.f)
dat.f=as.list(as.data.frame(model.matrix(mod4g)))
names(dat.f)
dat=c(dat.f, dat.a)
names(dat)
names(dat.f)=c("intercepto","dia","riegoWW","hongosH", "diariegoWW")
names(dat.f)
dat=c(dat.f, dat.a)
names(dat)
dat$Y = base2$diametro
dat$N = length(base2$diametro)
dat$p = length(levels(base2$planta))
names(dat)
#dat
stan.mod1 = "
data {
// Numero de observaciones
int<lower=0> N;
// Numero de plantas
int<lower=0> p;
// Variables de la parte sistemática / tomar como guia names(dat)
int <lower=0, upper=1> intercepto[N];
real dia[N];
int <lower=0, upper=1> riegoWW[N];
int <lower=0, upper=1> hongosH[N];
int <lower=0, upper=1>p12[N];
int <lower=0, upper=1>p13[N];
int <lower=0, upper=1>p14[N];
int <lower=0, upper=1>p15[N];
int <lower=0, upper=1>p16[N];
int <lower=0, upper=1>p18[N];
int <lower=0, upper=1>p19[N];
int <lower=0, upper=1>p21[N];
int <lower=0, upper=1>p210[N];
int <lower=0, upper=1>p23[N];
int <lower=0, upper=1>p24[N];
int <lower=0, upper=1>p25[N];
int <lower=0, upper=1>p26[N];
int <lower=0, upper=1>p27[N];
int <lower=0, upper=1>p29[N];
int <lower=0, upper=1>p310[N];
int <lower=0, upper=1>p32[N];
int <lower=0, upper=1>p33[N];
int <lower=0, upper=1>p34[N];
int <lower=0, upper=1>p35[N];
int <lower=0, upper=1>p36[N];
int <lower=0, upper=1>p37[N];
int <lower=0, upper=1>p38[N];
int <lower=0, upper=1>p41[N];
int <lower=0, upper=1>p410[N];
int <lower=0, upper=1>p42[N];
int <lower=0, upper=1>p43[N];
int <lower=0, upper=1>p44[N];
int <lower=0, upper=1>p45[N];
int <lower=0, upper=1>p46[N];
int <lower=0, upper=1>p47[N];
int <lower=0, upper=1>p48[N];
int <lower=0, upper=1>p49[N];
// Respuesta
real Y[N];
}
parameters {
// beta0: intercepto
real beta0;
// beta1: pendiente general
real beta1;
// tauR: efectos de riegoWW
real tauR;
// tauH: efectos de hongosHMA+
real tauH;
// delta: efectos de interacion dia:riegoWW
real delta;
// beta0i: efectos aleatorios sobre interceptos
real beta0i[p];
// beta1i: efectos aleatorios sobre pendiente
real beta1i[p];
// sigma0: desviación estándar de interceptos
real<lower=0> sigma0;
// sigma1: desviación estándar de pendientes
real<lower=0> sigma1;
// sigma_error: desviación estándar del error
real<lower=0> sigma_error;
}
transformed parameters  {
// Media condicional
real mu[N];
for (i in 1:N) {
mu[i] = beta0 + beta1*dia[i] + tauR*riegoWW[i] + tauH*hongosH[i] + delta*dia[i]*riegoWW[i] +
beta0i[1]*p12[i]+
beta0i[2]*p13[i]+
beta0i[3]*p14[i]+
beta0i[4]*p15[i]+
beta0i[5]*p16[i]+
beta0i[6]*p18[i]+
beta0i[7]*p19[i]+
beta0i[8]*p21[i]+
beta0i[9]*p210[i]+
beta0i[10]*p23[i]+
beta0i[11]*p24[i]+
beta0i[12]*p25[i]+
beta0i[13]*p26[i]+
beta0i[14]*p27[i]+
beta0i[15]*p29[i]+
beta0i[16]*p310[i]+
beta0i[17]*p32[i]+
beta0i[18]*p33[i]+
beta0i[19]*p34[i]+
beta0i[20]*p35[i]+
beta0i[21]*p36[i]+
beta0i[22]*p37[i]+
beta0i[23]*p38[i]+
beta0i[24]*p41[i]+
beta0i[25]*p410[i]+
beta0i[26]*p42[i]+
beta0i[27]*p43[i]+
beta0i[28]*p44[i]+
beta0i[29]*p45[i]+
beta0i[30]*p46[i]+
beta0i[31]*p47[i]+
beta0i[32]*p48[i]+
beta0i[33]*p49[i]+
beta1i[1]*p12[i]*dia[i]+
beta1i[2]*p13[i]*dia[i]+
beta1i[3]*p14[i]*dia[i]+
beta1i[4]*p15[i]*dia[i]+
beta1i[5]*p16[i]*dia[i]+
beta1i[6]*p18[i]*dia[i]+
beta1i[7]*p19[i]*dia[i]+
beta1i[8]*p21[i]*dia[i]+
beta1i[9]*p210[i]*dia[i]+
beta1i[10]*p23[i]*dia[i]+
beta1i[11]*p24[i]*dia[i]+
beta1i[12]*p25[i]*dia[i]+
beta1i[13]*p26[i]*dia[i]+
beta1i[14]*p27[i]*dia[i]+
beta1i[15]*p29[i]*dia[i]+
beta1i[16]*p310[i]*dia[i]+
beta1i[17]*p32[i]*dia[i]+
beta1i[18]*p33[i]*dia[i]+
beta1i[19]*p34[i]*dia[i]+
beta1i[20]*p35[i]*dia[i]+
beta1i[21]*p36[i]*dia[i]+
beta1i[22]*p37[i]*dia[i]+
beta1i[23]*p38[i]*dia[i]+
beta1i[24]*p41[i]*dia[i]+
beta1i[25]*p410[i]*dia[i]+
beta1i[26]*p42[i]*dia[i]+
beta1i[27]*p43[i]*dia[i]+
beta1i[28]*p44[i]*dia[i]+
beta1i[29]*p45[i]*dia[i]+
beta1i[30]*p46[i]*dia[i]+
beta1i[31]*p47[i]*dia[i]+
beta1i[32]*p48[i]*dia[i]+
beta1i[33]*p49[i]*dia[i];
}
}
model {
beta0i ~ normal(0, sigma0);
beta1i ~ normal(0, sigma1);
Y ~ normal(mu, sigma_error);
}
"
stan.fit1 <- stan(
model_code = stan.mod1,
data       = dat,
chains     = 1,
iter       = 100,
warmup     = 50,
cores      = parallel::detectCores(),
)
traceplot(stan.fit1, pars = c("beta0","beta1","sigma0","sigma1", "sigma_error"), inc_warmup = TRUE)
traceplot(stan.fit1, pars = c("beta0","beta1","sigma0","sigma1", "sigma_error"), inc_warmup = FALSE)
stan.fit1 <- stan(
model_code = stan.mod1,
data       = dat,
chains     = 2,
iter       = 500,
warmup     = 50,
cores      = parallel::detectCores(),
)
traceplot(stan.fit1, pars = c("beta0","beta1","sigma0","sigma1", "sigma_error"), inc_warmup = TRUE)
traceplot(stan.fit1, pars = c("beta0","beta1","sigma0","sigma1", "sigma_error"), inc_warmup = FALSE)
print( stan.fit1)
knitr::opts_chunk$set(echo = TRUE)
library(tidyr)
library(dplyr)
load("germinacion.Rdata")
#negat
vacios = names(which(table(base$altura,base$planta)[1,]>1))
`%notin%` <- Negate(`%in%`)
base2 <- base %>% filter( planta %notin% vacios)
#base3 = base[base$planta%in%vacios==F,]
#length(unique(base2$medida))
shapiro.test( residuals(mod1))
mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2)
shapiro.test( residuals(mod1))
car::leveneTest( residuals( mod2) ~ base2$planta)
car::leveneTest( residuals( mod1) ~ base2$planta)
predict( mod1)
predict( mod1); extract(mod1)
fittedmod1 = predict( mod1)
plot( fittedmod1, residuals( mod1))
mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = T, data = base2)
shapiro.test( residuals(mod1))
car::leveneTest( residuals( mod1) ~ base2$planta)
mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2)
shapiro.test( residuals(mod1))
car::leveneTest( residuals( mod1) ~ base2$planta)
options(contrasts=c("contr.sum","contr.poly"))
mod = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2)
shapiro.test( residuals(mod))
car::leveneTest( residuals( mod) ~ base2$planta)
fittedmod1 = predict( mod)
plot( fittedmod1, residuals( mod))
mody =
options(contrasts=c("contr.sum","contr.poly"))
mod = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2)
shapiro.test( residuals(mod))
car::leveneTest( residuals( mod) ~ base2$planta)
fittedmod1 = predict( mod)
plot( fittedmod1, residuals( mod))
mody = lm( abs( residuals( mod) ) ~ fittedmod1); s = predict(mody); w = 1/(w^2)
mody = lm( abs( residuals( mod) ) ~ fittedmod1); s = predict(mody); w = 1/(w^2)
shapiro.test( residuals(mod))
car::leveneTest( residuals( mod) ~ base2$planta)
fittedmod1 = predict( mod)
plot( fittedmod1, residuals( mod))
mody = lm( abs( residuals( mod) ) ~ fittedmod1)
s = predict(mody)
w = 1/(w^2)
options(contrasts=c("contr.sum","contr.poly"))
mod = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2)
shapiro.test( residuals(mod))
car::leveneTest( residuals( mod) ~ base2$planta)
fittedmod1 = predict( mod)
plot( fittedmod1, residuals( mod))
mody = lm( abs( residuals( mod) ) ~ fittedmod1)
s = predict(mody)
w = 1/(s^2)
mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = w)
shapiro.test( residuals(mod1))
car::qqPlot( residuals(mod1))
mod1 = lme4::lmer( log(altura) ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = w)
car::qqPlot( residuals(mod1))
shapiro.test( residuals( mod1))
mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = w)
anova(mod1)
summary(mod1)
1.747e+00
ks.test( residuals(mod1), "pnorm", mean=0, sd=sqrt(1.747))
t = summary(mod1)
summary(mod1)
View(t)
shapiro.test( residuals(mod))
car::leveneTest( residuals( mod) ~ base2$planta)
fittedmod1 = predict( mod)
plot( fittedmod1, residuals( mod))
mody = lm( abs( residuals( mod) ) ~ fittedmod1)
s = predict(mody)
w = 1/(s^2)
mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = w)
summary(mod1)
ks.test( residuals(mod1), "pnorm", mean=0, sd=sqrt(1.747))
mod2 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1|planta) + (0+dia|planta) , REML = F, data = base2, weights = w)
anova( mod1, mod2, test = "LRT")
mod3 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1|planta), REML = F, data = base2, weights = w)
anova( mod2, mod3, test = "LRT")
mod4 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego + (1|planta), REML = F, data = base2, weights = w)
anova( mod4, mod3, test = "LRT")
mod5 = lme4::lmer( altura ~ dia+riego+hongos + (1|planta), REML = F, data = base2, weights = w)
anova( mod5, mod4, test = "LRT")
modaltura = mod4 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego + (1|planta), REML = T, data = base2, weights = w)
modgg = lme4::lmer( diametro ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2)
shapiro.test( residuals(modgg))
car::leveneTest( residuals( modgg) ~ base2$planta)
fittedmod1 = predict( modgg)
plot( fittedmod1, residuals( mod))
mody = lm( abs( residuals( mod) ) ~ fittedmod1)
s = predict(mody)
wg = 1/(s^2)
#mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = wg)
mod1g = lme4::lmer( diametro ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = wg)
summary(mod1g)
sqrt(2.4046465)
summary(mod1g)
ks.test( residuals(mod1g), "pnorm", mean=0, sd=1.55069)
car::qqPlot( residuals(mod1g))
#mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = wg)
mod1g = lme4::lmer( log(diametro) ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = wg)
#mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = wg)
mod1g = lme4::lmer( log(diametro) ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = wg)
#mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = wg)
mod1g = lme4::lmer( log(diametro+1) ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = wg)
summary(mod1g)
ks.test( residuals(mod1g), "pnorm", mean=0, sd=0.316307)
#mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = wg)
mod1g = lme4::lmer( diametro ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = wg)
summary(mod1g)
ks.test( residuals(mod1g), "pnorm", mean=0, sd=1.55069)
car::qqPlot( residuals(mod1g))
#options(contrasts=c("contr.sum","contr.poly"))
mod2g = lme4::lmer( diametro ~ dia+riego+hongos+dia*riego+riego*hongos + (1|planta) + (0+dia|planta) , REML = F, data = base2, weights = wg)
anova( mod1g, mod2g, test = "LRT")
mod3g = lme4::lmer( diametro ~ dia+riego+hongos+dia*riego+riego*hongos + (1|planta), REML = F, data = base2, weights = wg)
anova( mod1g, mod3g, test = "LRT")
library( dplyr)
library(rstan)
library(lme4)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
base = openxlsx::read.xlsx("base.xlsx")
vacios = names(which(table(base$altura,base$planta)[1,]>1))
`%notin%` <- Negate(`%in%`)
#1:40
base2 <- base %>% filter( planta %notin% vacios)
base2$planta = as.factor(base2$planta)
levels(base2$planta)
library(tidyr)
library(dplyr)
load("germinacion.Rdata")
#negat
vacios = names(which(table(base$altura,base$planta)[1,]>1))
`%notin%` <- Negate(`%in%`)
base2 <- base %>% filter( planta %notin% vacios)
#base3 = base[base$planta%in%vacios==F,]
#length(unique(base2$medida))
shapiro.test( residuals(mod))
options(contrasts=c("contr.sum","contr.poly"))
mod = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2)
shapiro.test( residuals(mod))
car::leveneTest( residuals( mod) ~ base2$planta)
fittedmod1 = predict( mod)
plot( fittedmod1, residuals( mod))
mody = lm( abs( residuals( mod) ) ~ fittedmod1)
s = predict(mody)
w = 1/(s^2)
mod1 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego+riego*hongos + (1+dia|planta) , REML = F, data = base2, weights = w)
summary(mod1)
ks.test( residuals(mod1), "pnorm", mean=0, sd=sqrt(1.747))
modaltura = mod4 = lme4::lmer( altura ~ dia+riego+hongos+dia*riego + (1|planta), REML = T, data = base2, weights = w)
library( dplyr)
library(rstan)
library(lme4)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
base = openxlsx::read.xlsx("base.xlsx")
vacios = names(which(table(base$altura,base$planta)[1,]>1))
`%notin%` <- Negate(`%in%`)
#1:40
base2 <- base %>% filter( planta %notin% vacios)
base2$planta = as.factor(base2$planta)
levels(base2$planta)
modaltura #este viene del alchivo de estimacion frecuentista
summary( modaltura)
summary( modaltura)
t(as.matrix(attributes(modaltura)$pp$Zt))
View( t(as.matrix(attributes(modaltura)$pp$Zt)))
